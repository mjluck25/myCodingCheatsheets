--> Packages to install:

    1. Babel ES6/ES7
      --> gives syntax highlighting
    2. Node.js Modules Intellisense
    3. Node.js extension pack
    4. VS code for node.js development pack

---

using scrimba.com as IDE 
--> acc: gmail pw: number

---

Comments
  --> in-line comment 
    --> using //
  --> multi-line comment
    --> /* */

---

Data Types (input info)
  --> undefined
    --> not defined
  --> null
    --> nothing
  --> boolean
    --> true or false
  --> string
    --> text
  --> symbol
    --> unique value
  --> number
  --> object
    --> can store a lot of different value pairs

---

Variables (var)
--> syntax 1: var someText = "sometext"
  --> ie. var myName = "Mart"
  --> can be used throughout the whole program
--> syntax 2: someText = "sometext"
  --> ie. myName = "Mart"
  --> global variable because there is no var statement
--> syntax 3: let someText = "sometext"
  --> ie. let myName = "Mart"
  --> will only be used within the scope of where you declare them
  --> doesn't let you declare the same variable twice
--> syntax 4: const someText = "sometext"
  --> ie. const myName = "Mart"  
  --> a variable that should never change
  --> read-only
  --> variable that will not be reassigned
  --> usually declared in all capital letters
--> "use strict";
  --> used to catch coding mistakes such as not declaring variable without using var, let and const keywords
  --> can be placed on top of full js file or within a function

---

;
--> all lines in js should end with a semicolon
--> Semicolons are used to separate executable JavaScript statements.


---

console.log()
--> allows to see things in the console

---

WORKING with NUMBERS

incrementing/decrementing numbers

++
--> adding two plus signs after a variable increments it by one

--
--> adding two minus signs after a variable decrements it by one

decimal numbers (or float)

modulus/remainder(%)

exponential (**)

!=
--> not equal

augmented addition/subtraction/multiplication/division
--> += for addition
--> -= for subtraction
--> *= for multiplication
--> /= for division

Math.random()
--> generates random decimal number between 0 and 1 but does not equal to max (which is 1 in this example)

Math.floor()
--> rounds down to the nearest whole number

---

Escaping literal quotes in strings
--> add a backslash (\) before the quotation marks
--> or use a single quotation marks(')
--> or use a tilde (`)
--> backlash 
  --> use \\

--> Using Backticks (``)
  --> an ES6 feature that allows you to create strings in JS
  --> used in string concatenation:
	--> ie. let number = 5 
	        console.log(`${number} Articles`)
		returns 5 Articles
  --> can create multiline w/o using new line character (\n)
	--> ie. console.log(`"Hello
		Readers!!!"`)
		returns "Hello
			Readers!!!"

Adding Sequences in strings
--> newline
  --> use \n
--> carriage return
  --> use \r
--> tab
  --> use \t 
--> backspace
  --> use \b
--> form feed
  --> use \f

---

.length function
--> to know the number of characters in a string

bracket notation []
--> to find the index of a string
--> also to store multiple values separated by a comma (called arrays)
  --> nested arrays (bracked within a bracket of values)
  --> can also be indexed
  --> array indexes to modify data with that index
--> to access the array of an array use double brackets notation
  --> [][]

.push() function
--> to insert or add values at the end of an array

.pop() function
--> to remove the last value within an array
--> no value needed to insert

.shift() function
--> removes the first value within an array
--> no value needed to insert

.unshift() function
--> to insert or add values at the beginning of an array

.slice() method
--> returns a shallow copy of a portion of an array into a new array object selected from start to end (end not included) where start and end represent the index of items in that array. The original array will not be modified. 

---

function ()
--> creates a reusable code in js
--> syntax(1): function functionName() {}
--> syntax(2): const/var/let functionName = function() {}
--> syntax(3): const/var/let functionName = () => {}
  --> function word
  --> functionName(): can pass information in the parenthesis
  --> {}: everything inside the curly bracket will be run everytime the 

functionName was called/invoked
--> can be made "self-invoking"
  --> executed automatically if the expression is followed by ()
  --> syntax: 
        --> (function(empty){code})();

function with parameters
--> we can pass input data into the function using perameters or variables
--> ie. functionName(param1, param2): param1 and param2 can be any variable you set

Parameters
--> are the names listed in the function definition.
--> in ES6, default parameters are added
	--> ie. function functionName (name = 'someName'){}

Arguments
--> are the real values passed to (and received by) the function.


---

Scope
--> refers to the visibility of variables
  
  Global scope
  --> variables defined outside a function block
  --> can be seen throughout the js code
  --> setting a variable without the "var" keyword automatically makes it global even if it's defined within a function

  Local scope
  --> variables defined within a function as well as the function parameters

---

return statement
--> return a value from a function
--> ie. function functionName(){
  return anyValue
}
--> if the return statement is not declared, the return value will be undefined and nothing will be returned by the function
--> the execution of a function is stopped in a return statement where the code that follows it will not be executed. 

---

Queue
--> an abstract data structure where items are kept in order where new items can be added at the back of the queue while old items are taken off at the beginning of the queue. 

---

JSON.stringify
--> a way to change an array into a string that can easily be printed out in a screen

---

If statements
--> syntax: 
      function functionName(){if (condition{code to be executed})}
--> {}: executes the code in the curly brackets
--> (): conditions defined

---

Equality operator (==)
--> often used in if statements
--> most common comparison operator that uses boolean statements
--> attempts to convert both values being compared to a common type 

Strict Equality operator (===)
--> does not convert values being compared to a common type (ie. number === string will be false)

Inequality operator (!=)

Strict Inequality operator (!==)

greater than (>) or equal to (>=)

less than (<) or equal to (<=)

---

Logical operators
--> always evaluated from left to right

And operator (&&)

Or statement (||)
--> can be used in short circuit evaluation (where setting a default value if the value being set is falsy)
-->ie. 	let x = '';
	let y = x || 'default';

not operator (!)
--> also called bang operator

Short circuit Evaluation
--> if the first condition is met, there is no need to evaluate the second condition.

---

Else statements
--> alternate block of code to be executed if a given condition is not met
--> syntax: if(condition){code;} else {code;}

Else if statements
--> more than one conditions
--> logical order is important (always call the first condition first then next)

Switch statements
--> tests the value and can have many case statements which defines various possible values
--> default statement: sets the value of the variable whenever the input data is not within the cases
--> break: breaks the code per case
--> syntax: 
        function functionName(value){
          var variable = "";
          switch(value){
            case 1:
              variable = "some value";
              break;
            case 2: 
              variable = "some value";
              break; 
            default: 
              variable = "some value";
              break;
          }
          return value;
        }
--> multiple inputs give the same output (just omit the break statment and retain it in the last case)

---

Objects
--> similar to arrays but differ in using property in accessing data through curly braces {}
--> property: everything before a colon (:)
  --> ie. "dog": "Gon" --> "dog is the property"
--> syntax: 
      var objectName = {"property1": "value1", "property2": "value2", etc..};

  Dot notation
  --> used to access object properties
  --> syntax:
        objectName.property1;
  
  Bracket notation
  --> also used to access object properties
  --> required to be used if the property has spaces in it
  --> also used in storing property in a variable
  --> syntax:
        objectName['property 1'];

  delete statement
  --> to delete a property from an object
  -->syntax:
        delete objectName.property1;

  .hasOwnProperty method
  --> to check if the object has a property

  JSON.parse(JSON.stringify(Object))
  --> to create a copy of the original object

---

While Loops 
--> runs the same code multiple times while a certain condition is true and stops if it is false
--> always checks first the condition before it runs the code within the Loop
--> syntax:
      while (condition) {code}

Do While Loops
--> will always run the code one time before it checks the condition

For Loops
--> runs the same code multiple times given an initialization, condition, and final expression
--> syntax:
      for (initialization; condition; final expression) {code}
--> initialization: first expression in the code. or where to start from
--> condition: iteration of the first expression. or how many times we want to execute
--> final expression: what will execute at each iteration

For...in Loops
--> loops through the properties of an object
--> the block of code will be executed once for each property
--> syntax: 
	for (let variable in object) { block of code}
--> returns the key element of the object or array

For...of loops
--> syntax:
	for (let items in array) {}
--> iterates over the items of an array (from first to last item)
--> can also be used in iterating over the characters of a string
--> cannot be used to iterate in reverse


break keyword
--> terminates a loop



continue keyword
--> skip one iteration of a loop



---

parseInt function
--> converts a string into an integer
--> if the string cannot be converted into an integer, it will return "NaN" meaning "not a number"
--> can also be used with a radix
  --> radix: specifies the base of the number in the string
    --> such as base 2 (binary) or base 7 or base 8, base 10 (default)
  --> syntax:
        parseInt(str, radix)--> ie. parseInt("56", 2)

---

Ternary operator
--> like a one line if else expression
--> syntax:
      condition ? statement-if-true : statement-if-false;

---

Object.freeze() function
--> prevents object from mutation or changing

---

Anonymous functions
--> functions that don't have a name
--> can be converted into arrow functions for easier writing
--> syntax:
      function(){code};

Arrow functions
--> replaces the function keyword
--> are not well suited for defining object methods.
--> work really well with higher order functions such as math, filter and reduce 
  --> higher order functions: take functions as arguments for processing collections of data
--> syntax:
      () => {}

Concise body arrow functions
--> with single parameter, there is no need for parenthesis
--> with 2 or more parameter or if the parameter is zero, parenthesis is needed
--> if function body is single line, return keyword and curly braces is not needed (also called as implicit return)

---

map function (.map())
--> takes a function as an argument

filter function (.filter())
--> filters an object or an array

---

rest operator ((...args))
--> allows to create a function that creates a variable number of arguments
--> three dots

spread operator([...args])
--> takes an array and spreads out into its individual arrays

---

Destructuring assignment of variables from arrays
--> assignment of variables within the array is in order
--> syntax: 
      [var1,var2,var3,,,,var7] = [a,b,c,d,e,f,g]
      --> var1 = a, var2 = b, var7 = g
      --> to access a specific element within the array, just add comma

---

Template Literals
--> are special type of string that makes reading complex strings easier
--> used using backticks (``)

---

JS Iterables
--> Objects that can be iterated over with for..of are called iterable.

for..of loop
--> iterating a string
syntax: for (cons x of "some string") {block of code}
--> iterating over an array
syntax: for (const x of [1,2,3,4,5]) {block of code}


next() method
--> an object becomes an iterator when this is implemented
--> does not support for..of statement
--> must return an object with two properties: value (next value) and done (boolean)
	--> value: the value returned by the iterator (can be omitted if done is true)
	--> done: TRUE if the iterator has completed and FALSE if the iterator has produced a new value
example:
// Home Made Iterable
function myNumbers() {
  let n = 0;
  return {
    next: function() {
      n += 10;
      return {value:n, done:false};
    }
  };
}

// Create Iterable
const n = myNumbers();
n.next(); // Returns 10
n.next(); // Returns 20
n.next(); // Returns 30


Symbol.iterator
--> a function that returns a next() function
--> can be iterated over with code: for (const x of iterable) {}
example:
myNumbers = {}
myNumbers[Symbol.iterator] = function() {
 let n = 0;
 done = false;
 return {
  next() {n+=10;
  if (n==100){done=true}
  return {value:n, done:done}
  }
 }
}
this code can now be used:
	for (const num of myNumbers) {}

--> manually, we can use this code:
let iterator = myNumbers[Symbol.iterator]();

while (true) {
  const result = iterator.next();
  if (result.done) break;
  // Any Code Here
}


---

JS Sets (new Set())
--> a collection of unique values
--> each value can only occur once in a Set
--> can hold any value of any data type
Methods
new Set()	
	--> Creates a new Set
add()	
	--> Adds a new element to the Set
delete()	
	--> Removes an element from a Set
has()	
	--> Returns true if a value exists
clear()	
	--> Removes all elements from a Set
forEach()
	--> Invokes a callback for each element
values() /keys()
	--> Returns an Iterator with all the values in a Set
entries()	
	--> Returns an Iterator with the [value,value] pairs from a Set

Property	
size	
	--> Returns the number elements in a Set


---

JS Maps
--> holds key-value pairs where keys can be any datatype
--> remembers the original insertion order of the keys
--> has a property that represents the size of the map
--> Being able to use objects as keys is an important Map feature.


---

Hoisting
-->  allows access to function declarations before they’re defined.
--> function expressions are not hoisted



---

pass-by-reference
--> where we pass to a function a reference to where the variable memory is stored and changing the memory. 
--> common example are OBJECTS.


---

Privacy
--> the idea that only certain properties should be mutable or able to change in value.
--> common convention is to place an underscore _ before the name of a property to mean that the property should not be altered.


---

Getters
--> methods that get and return the internal properties of an object.
--> we use the 'get' keyword
--> getter methods do not need to be called with a set of parentheses.
--> can perform an action on the data when getting a property.
--> can return different values using conditionals. 
--> can access the properties of the calling object using this.
--> when using getter (and setter) methods is that properties cannot share the same name as the getter/setter function.


Setters
--> reassign values of existing properties within an object.

---

Factory Functions
--> is a function that returns an object and can be reused to make multiple object instances.
--> can also have parameters allowing us to customize the object that gets returned.
--> syntax:
	const factoryFunctionName = (param1, param2, etc.) = {
		return {param1: param1, param2: param2} 
		//return an object and uses the parameters as its values
	}
	const someVariableName = factoryFunctionName(param1, param2) //invoke the factory function and store it to the variable with two parameters


---

Property Value Shorthand (ES6)
--> a destructuring technique
--> we only use the key instead of assigning it a value of the parameter


Destructured assignment
--> we create a variable with the name of an object’s key that is wrapped in curly braces { } and assign to it the object.
--> syntax:
	const object = {
	prop1: value1,
	prop2: value2
	}
	To access the properties and store in a variable:
	const { prop2 } = object; 
//no need to do: const prop2 = object.prop2
	

---
Some Built-in Object Properties

Object.assign() method
--> copies all enumerable own properties from one or more source objects to a target object. 
--> It returns the modified target object. 
--> syntax:
	Object.assign(target, ...sources) //returns target object
	ie. const someVariable = Object.assign({}, source1, {prop1: value1, prop2: value2})

Object.entries() method
--> returns an array of the key-value pairs in an object passed as an argument
--> syntax:
	Object.entries(object);

Object.keys(method)
--> returns an array of a given object's own enumerable property names, iterated in the same order that a normal loop would.
--> syntax: 
	Object.keys(object);


---

Higher order functions
--> functions that accept other functions as arguments and/or return functions as output
--> storing functions into a variable
	--> const variableName = functionName; //note that it doesn't have () at the end
//We want to assign the value of the function itself, not the value it returns when invoked. 

--> functions are first class objects and can also have its own properties and methods(like .name or .length)

Callback functions
--> functions that get passed in as parameters and invoked within the block of the higher order function
--> they get called during the execution of the higher-order function.
--> we pass in the function itself by typing the function name without the parentheses (that would evaluate to the result of calling the function)


---

Iterators
--> are methods called on arrays to manipulate elements and return values.
--> function declaration, function expression and arrow function can be used to supply a callback function as an argument to the iterator.
--> mutator methods
	--> methods that modify the original array
--> accessor methods
	--> methods that return a new value or representation

.forEach() method
--> will execute the same code for each element of an array.
--> During each execution, the current element is passed as an argument to the callback function.
--> return value for .forEach() will always be UNDEFINED.
--> Another way to pass a callback for .forEach() is to use arrow function syntax. 
--> We can also define a function beforehand to be used as the callback function.
	--> ie. 
	function printGrocery(element){
  	  console.log(element);
	}
 
	groceries.forEach(printGrocery);

.map() method
--> takes an argument of a callback function and returns a new array.
--> It doesn't modify the original array. 

.filter() method
-->  returns a new array.
--> returns an array of elements after filtering out certain elements from the original array.
--> callback function for the .filter() method should return true or false depending on the element that is passed to it.
--> The elements that cause the callback function to return true are added to the new array.
--> It doesn't modify the array.


.findIndex() method
--> to find the location of an element in an array. 
--> will return the index of the first element that evaluates to true in the callback function.
--> returns -1 if none of the elements in the array satisfies the condition. 
-->  check a condition for each element of an array, until the condition is met, and get the index of the first array element that passes said condition.
--> syntax: .findIndex(callBackFcn)

.indexOf() method
--> find the index of the first occurrence of a specific value in an array.
--> syntax: arr.indexOf(searchElement, fromIndex)

.reduce() method
--> returns a single value after iterating through the elements of an array, thereby reducing the array.
--> can also take an optional second parameter to set an initial value for accumulator (remember, the first argument is the callback function!). .reduce((accumulator, currentValue) => {firstArg}, secondArg) //accumulator is the firstArg, currentValue is secondArg


.some() method
--> tests whether at least one element in the array passes the test implemented by the provided function.
--> It returns true if, in the array, it finds an element for which the provided function returns true; otherwise it returns false. 
--> It doesn't modify the array. 


.every() method
--> tests whether all elements in the array pass the test implemented by the provided function. 
--> It returns a Boolean value. 


.includes() method
--> determines whether an array includes a certain value among its entries, returning true or false as appropriate. 


.find() method
--> returns the first value in an array that passes a given test.


.slice() method
-->  returns a shallow copy of a portion of an array into a new array object selected from start to end (end not included) where start and end represent the index of items in that array. 
--> the original array will not be modified. 


.splice() method
--> changes the contents of an array by removing or replacing existing elements and/or adding new elements in place.
--> parameters:
	.splice(startIndex, deleteCount, ItemToAdd1, ItemToAdd2...)





Notes
1. linting, a process by which text is evaluated and improved by an application